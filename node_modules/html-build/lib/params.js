"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const _ = require("lodash");
const util_1 = require("./util");
const regexTagStartTemplate = "<!--\\s*%parseTag%:(\\w+)\\s*(inline)?\\s*(optional)?\\s*(recursive)?\\s*(noprocess)?\\s*([^\\s]*)\\s*(?:\\[(.*)\\])?\\s*-->", // <!-- build:{type} (inline) (optional) (recursive) {name} [attributes...] --> {} required () optional
regexTagEndTemplate = "<!--\\s*\\/%parseTag%\\s*-->"; // <!-- /build -->
function getParams(src, opt) {
    const params = Object.assign({
        beautify: false,
        logOptionals: false,
        relative: true,
        keepTags: false,
        scripts: {},
        styles: {},
        sections: {},
        data: {},
        parseTag: "build",
        processFiles: false,
        processPath: defaultProcessPath
    }, opt || {});
    setTagRegexes(params, params.parseTag);
    params.filesContext = createFilesContext(src);
    return params;
}
exports.getParams = getParams;
/** Takes an array of paths and validates them. */
function defaultProcessPath(pathes, params, opt) {
    const flattenPaths = Array.isArray(pathes) ? _.flattenDeep(pathes) : pathes, remote = flattenPaths.filter(path => /^((http|https):)?(\\|\/\/)/.test(path)); //is http, https, or // (for loading from cdn)
    let local = util_1.expand(pathes, opt);
    if (params.relative && opt.cwd) {
        local = local.map(src => path.join(opt.cwd, src));
    }
    return _.uniq(local.concat(remote));
}
function setTagRegexes(params, parseTag) {
    params.regexTagStart = regexTagStartTemplate.replace(/%parseTag%/, () => parseTag);
    params.regexTagEnd = regexTagEndTemplate.replace(/%parseTag%/, () => parseTag);
}
function createFilesContext(src) {
    return {
        path: src,
        dir: path.dirname(src),
        file: path.basename(src),
        filename: path.basename(src, path.extname(src)),
        dirname: path.basename(path.dirname(src)),
        platform: process.platform
    };
}
